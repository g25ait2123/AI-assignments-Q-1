# ------------------------------------------
# Security Bot Assignment CSP
# ------------------------------------------

from copy import deepcopy

# Variables (Time Slots)
VARIABLES = ["Slot1", "Slot2", "Slot3", "Slot4"]

# Domain (Bots)
BOTS = ["A", "B", "C"]

# Initial Domains
DOMAINS = {
    "Slot1": ["A", "B", "C"],
    "Slot2": ["A", "B", "C"],
    "Slot3": ["A", "B", "C"],
    "Slot4": ["A", "B"]  # C cannot work in Slot4 (Maintenance Constraint)
}


# ------------------------------------------
# Constraint Checking
# ------------------------------------------

def is_valid(assignment, var, value):
    temp = assignment.copy()
    temp[var] = value

    # 1️⃣ No Back-to-Back constraint
    for i in range(1, 4):
        s1 = f"Slot{i}"
        s2 = f"Slot{i+1}"
        if s1 in temp and s2 in temp:
            if temp[s1] == temp[s2]:
                return False

    return True


# ------------------------------------------
# Minimum Coverage Check
# ------------------------------------------

def minimum_coverage(assignment):
    # Ensure all bots A, B, C appear at least once
    used = set(assignment.values())
    return all(bot in used for bot in BOTS)


# ------------------------------------------
# MRV Heuristic
# ------------------------------------------

def select_unassigned_variable(assignment, domains):
    unassigned = [v for v in VARIABLES if v not in assignment]
    return min(unassigned, key=lambda var: len(domains[var]))


# ------------------------------------------
# Forward Checking
# ------------------------------------------

def forward_check(domains, var, value):
    new_domains = deepcopy(domains)

    # Remove same bot from adjacent slots
    slot_num = int(var[-1])

    for neighbor in [slot_num - 1, slot_num + 1]:
        if 1 <= neighbor <= 4:
            neighbor_var = f"Slot{neighbor}"
            if value in new_domains[neighbor_var]:
                new_domains[neighbor_var].remove(value)

    return new_domains


# ------------------------------------------
# Backtracking Search with MRV + FC
# ------------------------------------------

def backtrack(assignment, domains):
    if len(assignment) == len(VARIABLES):
        if minimum_coverage(assignment):
            return assignment
        return None

    var = select_unassigned_variable(assignment, domains)

    for value in domains[var]:
        if is_valid(assignment, var, value):
            new_assignment = assignment.copy()
            new_assignment[var] = value

            new_domains = forward_check(domains, var, value)

            result = backtrack(new_assignment, new_domains)
            if result:
                return result

    return None


# ------------------------------------------
# Run CSP
# ------------------------------------------

if __name__ == "__main__":
    solution = backtrack({}, DOMAINS)

    if solution:
        print("Solution Found:")
        for slot in VARIABLES:
            print(slot, "->", solution[slot])
    else:
        print("No Solution Found.")
